# -*- encoding: utf-8 -*-
"""
Test fixture for ephys spike methods
Provide synthesis of test data, and run each of the tests.
"""

import dataclasses
import sys
from typing import Union
import time
from dataclasses import dataclass, field
import pickle
from pathlib import Path
import numpy as np
import scipy.signal
import pyqtgraph as pg

import ephys.ephys_analysis.rm_tau_analysis as RMT
import ephys.ephys_analysis.spike_analysis as SA

from ephys.mini_analyses.util import UserTester

testmode = False  # set false to hold graphs up until closed;
# true for 2 sec display

# for reference - the HHIV data comes in with this class structure
@dataclass
class HHIV:  # mimics "Clamps" in spike and 
    mode:str = 'ic'
    traces: object=None
    cmd_wave: object=None
    values: object=None
    commandLevels: object=None  # for rmtau
    time_base: object=None
    tstart: float=0.02  # in seconds
    tend: float = 0.07  # in seconds
    tdur: float = 0.2  # in seconds
    sample_interval: float = 1e-5  # in seconds


def printPars(pars):
    print(dir(pars))
    d = dataclasses.asdict(pars)
    for k in d.keys():
        print("k: ", k, " = ", d[k])


# these are the tests that will be run


def test_spikes():
    SpikeTester(extra="python")  # default method


# def test_spikes_cython():
#     SpikeTester(extra="cython")  # accelerated method


# def test_rmtau():
#     RmTauTester(extra="python")


# def test_rmtau():
#     RmTauTester(extra="cython")

def get_testdata(
):
    """
    The test data is generated by hh_sim
    Here we just read it

    """
    testpath = Path(__file__).parent # this assumes we are running in the same directory as the test data file

    with open(Path(testpath, "HHData.pkl"), "rb") as fh:
        IV = pickle.load(fh)

    return IV



def run_spike_tester_python(plot:bool=True):
    testdata  = get_testdata()
    spike_analyzer = SA.SpikeAnalysis()
    spike_analyzer.setup(clamps = testdata, threshold=-0.020)
    spike_analyzer.analyzeSpikes()
    testresult = spike_analyzer.analysis_summary
    # print(testresult.keys())
    spike_analyzer.analyzeSpikeShape()
    spksh = spike_analyzer.spikeShape
    print(testdata.traces)
    if plot:
        for i, t in enumerate(testdata.traces):
            print("i: ", i)
            mpl.plot(testdata.time_base, testdata.traces[i])

            if i in spksh.keys():
                sh = spksh[i]
                print(sh)
                for j in sh.keys():
                    mpl.plot(sh[j].peak_T, sh[j].peak_V, 'ro')
        
        
        mpl.show()
    print(testresult)
    return testresult



class SpikeTester(UserTester):
    def __init__(self, method="python"):
        self.TM = None
        self.figure = None
 
        UserTester.__init__(self,  method=method) # f"{method:s}")
        # UserTester.__init__(self, "%s_%s" % (method, extra), method)
        # if you want to store different results by the "extra" parameter

    def run_test(self, method):

        self.STM = SpikeTestMethods(method=method)
        test_result = self.STM.run_test()

        if "figure" in list(test_result.keys()):
            self.figure = test_result["figure"]
        return test_result

    def assert_test_info(self, *args, **kwds):
        try:
            super(SpikeTester, self).assert_test_info(*args, **kwds)
        finally:
            if self.figure is not None:
                del self.figure


def plot_traces_and_markers(method, dy=20e-12, sf=1.0, mpl=None):
    if mpl is None:
        import matplotlib.pyplot as mpl
    tba = method.timebase[: len(method.Summary.allevents[0])]
    last_tr = 0
    dyi = 0
    for i, a in enumerate(method.Summary.allevents):
        dyi += dy
        if np.isnan(a[0]):  # didn't fit.
            continue
        mpl.plot(tba, sf * a + dyi)
        jtr = method.Summary.event_trace_list[i]  # get trace and event number in trace
        if len(jtr) == 0:
            continue
        if jtr[0] > last_tr:
            last_tr = jtr[0]
            dyi = dyi + 10 * dy
        # print('sm, on', i, jtr, len(method.Summary.smpkindex[jtr[0]]), len(method.Summary.onsets[jtr[0]]))
        pk = method.Summary.smpkindex[jtr[0]][jtr[1]]
        on = method.Summary.onsets[jtr[0]][jtr[1]]
        onpk = (pk - on) * method.dt_seconds
        mpl.plot(
            onpk,
            sf * method.Summary.smoothed_peaks[jtr[0]][jtr[1]] + dyi,
            "ro",
            markersize=4,
        )
        pk = method.Summary.peaks[jtr[0]][jtr[1]]
        on = method.Summary.onsets[jtr[0]][jtr[1]]
        onpk = (pk - on) * method.dt_seconds
        mpl.plot(
            onpk,
            sf * method.Summary.amplitudes[jtr[0]][jtr[1]] + dyi,
            "ys",
            markersize=4,
        )


if __name__ == "__main__":
    ntraces = 1
    methods = [
        "python",
        "cython",
    ]
    testmethod = None
    print(len(sys.argv))
    if len(sys.argv) <= 1:
        print(f"Must specify test method from: ")
        methodnames = [f"    {m:s}\n" for m in methods]
        print(methodnames)
        exit()

    if len(sys.argv) > 1:
        testmethod = sys.argv[1]
    if testmethod not in methods:
        print("Test for %s method is not implemented" % testmethod)
        exit(1)
    else:
        # set up for plotting
        import matplotlib
        import warnings  # need to turn off a scipy future warning.
        import matplotlib.pyplot as mpl

        if testmethod in ["python"]:
                analysis_summary = run_spike_tester_python()
                print("All detected spikes: ", analysis_summary)
                # f, ax = mpl.subplots(1, 1)
                # f.set_size_inches(5, 10)
                # plot_traces_and_markers(cb)
                # mpl.show()
        pass
    
        if testmethod in ["all", "ALL"]:
            pass
    