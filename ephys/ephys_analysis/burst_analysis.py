import numpy as np
from collections import defaultdict
import matplotlib.pyplot as mpl
import pylibrary.plotting.plothelpers as PH

""" Burst analyzer for spike time data across multiple trials.
Analyze spike time data from multiple trials to detect and characterize bursts.
Original generated by DeepSeek on 14 Mar 2025.
Testing is done in the test function, called from the main block.


Returns
-------
_type_
    _description_

Raises
------
ValueError
    _description_
"""


class BurstAnalyzer:
    def __init__(self, trials, trial_start_times, max_ISI=0.1, min_spikes=3):
        """
        Initialize burst analyzer with spike time data from multiple trials.

        Parameters:
        trials: List of spike time arrays (relative to trial start)
        trial_start_times: Array of absolute start times for each trial
        max_ISI: Maximum inter-spike interval (seconds) for burst detection
        min_spikes: Minimum spikes required to form a burst
        """
        if len(trials) != len(trial_start_times):
            raise ValueError("Trials and trial_start_times must have same length")

        self.relative_spikes = [np.sort(t) for t in trials]
        self.trial_starts = np.array(trial_start_times)
        self.max_ISI = max_ISI
        self.min_spikes = min_spikes

        # Convert to absolute timestamps
        self.absolute_spikes = [
            start + spikes for start, spikes in zip(self.trial_starts, self.relative_spikes)
        ]

        self.bursts = []
        self._detect_bursts()

    def _detect_bursts_in_trial(self, abs_spike_times, trial_idx):
        """Detect bursts in a single trial's absolute spike times"""
        bursts = []
        if len(abs_spike_times) < self.min_spikes:
            return bursts

        in_burst = False
        burst_start = None
        burst_spikes = []

        for i in range(1, len(abs_spike_times)):
            isi = abs_spike_times[i] - abs_spike_times[i - 1]

            if not in_burst and isi <= self.max_ISI:
                in_burst = True
                burst_start = abs_spike_times[i - 1]
                burst_spikes = [abs_spike_times[i - 1], abs_spike_times[i]]
            elif in_burst:
                if isi <= self.max_ISI:
                    burst_spikes.append(abs_spike_times[i])
                else:
                    if len(burst_spikes) >= self.min_spikes:
                        duration = burst_spikes[-1] - burst_start
                        rate = (len(burst_spikes) - 1) / duration
                        bursts.append(
                            {
                                "start": burst_start,
                                "end": burst_spikes[-1],
                                "duration": duration,
                                "spikes": burst_spikes.copy(),
                                "rate": rate,
                                "trial": trial_idx,
                                "trial_start": self.trial_starts[trial_idx],
                            }
                        )
                    in_burst = False
                    burst_spikes = []

        # Handle final burst
        if in_burst and len(burst_spikes) >= self.min_spikes:
            duration = burst_spikes[-1] - burst_start
            rate = (len(burst_spikes) - 1) / duration
            bursts.append(
                {
                    "start": burst_start,
                    "end": burst_spikes[-1],
                    "duration": duration,
                    "spikes": burst_spikes,
                    "rate": rate,
                    "trial": trial_idx,
                    "trial_start": self.trial_starts[trial_idx],
                }
            )

        return bursts

    def _detect_bursts(self):
        """Detect bursts across all trials using absolute timing"""
        self.bursts = []
        for trial_idx, abs_spikes in enumerate(self.absolute_spikes):
            self.bursts.extend(self._detect_bursts_in_trial(abs_spikes, trial_idx))
        self.bursts.sort(key=lambda x: x["start"])

    def calculate_evolution(self, bin_type="trial", bin_size=1):
        """
        Calculate burst statistics evolution with multiple binning strategies.

        Parameters:
        bin_type: 'trial' (group trials), 'time' (fixed duration), or 'mixed' (both)
        bin_size: Size of bins in trials or seconds depending on type

        Returns: Dictionary of evolving statistics with trial and time perspectives
        """
        stats = {"by_trial": [], "by_time": []}

        if not self.bursts:
            return stats

        # Trial-based binning
        if bin_type in ["trial", "mixed"]:
            trial_bursts = defaultdict(list)
            for burst in self.bursts:
                trial_bursts[burst["trial"]].append(burst)

            sorted_trials = sorted(trial_bursts.keys())
            for i in range(0, len(sorted_trials), bin_size):
                bin_trials = sorted_trials[i : i + bin_size]
                bin_bursts = [b for t in bin_trials for b in trial_bursts[t]]

                stats["by_trial"].append(
                    {
                        "trials": bin_trials,
                        "start_time": self.trial_starts[bin_trials[0]],
                        "end_time": self.trial_starts[bin_trials[-1]]
                        + (
                            self.relative_spikes[bin_trials[-1]][-1]
                            if len(self.relative_spikes[bin_trials[-1]]) > 0
                            else 0
                        ),
                        "n_bursts": len(bin_bursts),
                        "mean_rate": (
                            np.mean([b["rate"] for b in bin_bursts]) if bin_bursts else np.nan
                        ),
                        "mean_duration": (
                            np.mean([b["duration"] for b in bin_bursts]) if bin_bursts else np.nan
                        ),
                        "mean_spikes": (
                            np.mean([len(b["spikes"]) for b in bin_bursts])
                            if bin_bursts
                            else np.nan
                        ),
                    }
                )

        # Time-based binning
        if bin_type in ["time", "mixed"]:
            start_time = min(b["start"] for b in self.bursts)
            end_time = max(b["end"] for b in self.bursts)

            for bin_start in np.arange(start_time, end_time, bin_size):
                bin_end = bin_start + bin_size
                bin_bursts = [b for b in self.bursts if bin_start <= b["start"] < bin_end]

                stats["by_time"].append(
                    {
                        "start": bin_start,
                        "end": bin_end,
                        "n_bursts": len(bin_bursts),
                        "mean_rate": (
                            np.mean([b["rate"] for b in bin_bursts]) if bin_bursts else np.nan
                        ),
                        "mean_duration": (
                            np.mean([b["duration"] for b in bin_bursts]) if bin_bursts else np.nan
                        ),
                        "mean_spikes": (
                            np.mean([len(b["spikes"]) for b in bin_bursts])
                            if bin_bursts
                            else np.nan
                        ),
                        "trials_included": list({b["trial"] for b in bin_bursts}),
                    }
                )

        return stats

    def trial_metrics(self):
        """Get burst metrics per individual trial"""
        metrics = []
        trial_bursts = defaultdict(list)
        for burst in self.bursts:
            trial_bursts[burst["trial"]].append(burst)

        for trial in sorted(trial_bursts.keys()):
            bursts = trial_bursts[trial]
            metrics.append(
                {
                    "trial": trial,
                    "start_time": self.trial_starts[trial],
                    "n_bursts": len(bursts),
                    "mean_rate": np.mean([b["rate"] for b in bursts]) if bursts else np.nan,
                    "mean_duration": np.mean([b["duration"] for b in bursts]) if bursts else np.nan,
                    "mean_spikes": (
                        np.mean([len(b["spikes"]) for b in bursts]) if bursts else np.nan
                    ),
                }
            )
        return metrics

    def plot_evolution(self, evolution: dict, method: str = "trial", ax: object = None):
        if ax is None:
            fig, ax = mpl.subplots(4, 1, figsize=(10, 10))
        # print(evolution["by_time"])
        # exit()
        colors = mpl.get_cmap("tab20", len(evolution["by_trial"]))
        if method == "trial":
            for i, bin_data in enumerate(evolution["by_trial"]):
                print("i: ", i)

                ax[0].plot(bin_data["start_time"], bin_data["n_bursts"], "o", color=colors(i))
                ax[1].plot(bin_data["start_time"], bin_data["mean_rate"], "o", color=colors(i))
                ax[2].plot(bin_data["start_time"], bin_data["mean_duration"], "o", color=colors(i))
        elif method == "time":

            for i, bin_data in enumerate(evolution["by_time"]):
                ax[0].plot(bin_data["start"], bin_data["n_bursts"], "o")
                ax[1].plot(bin_data["start"], bin_data["mean_rate"], "o")
                ax[2].plot(bin_data["start"], bin_data["mean_duration"], "o")
        else:
            raise ValueError("Method must be either 'trial' or 'time'")
        for i, sprow in enumerate(self.relative_spikes):
            ax[3].plot(sprow, i+np.ones_like(sprow) * 0, "|")
        ax[0].set_ylim(0, max([bin_data["n_bursts"] for bin_data in evolution["by_trial"]]) + 1)
        ax[1].set_ylim(0, max([bin_data["mean_rate"] for bin_data in evolution["by_trial"]]) + 1)
        ax[2].set_ylim(0, max([bin_data["mean_duration"] for bin_data in evolution["by_trial"]]) + 1)
        ax[0].set_ylabel("\# Bursts")
        ax[1].set_ylabel("Mean burst Rate (Hz)")
        ax[2].set_ylabel("Mean burst Duration (s)")
        ax[3].set_ylabel("Trial")
        for a in ax:
            PH.nice_plot(a)
        fig.tight_layout()
        return


def burst_maker(
    ntrials, mean_spikes_per_burst, mean_interburst_interval, 
    mean_interburst_std,
    mean_burst_duration, trial_duration
):
    spike_times = []
    for trial in range(ntrials):
        spikes = []
        t = 0.0
        while t < trial_duration:
            if np.random.rand() < (1./mean_interburst_interval) * mean_burst_duration:
                n_spikes = np.random.poisson(mean_spikes_per_burst)
                spikes.extend(t + np.random.rand(n_spikes) * mean_burst_duration)
            t += mean_interburst_interval + mean_interburst_std*np.random.standard_normal(1)
        spike_times.append(np.array(spikes))
    return spike_times


def test():
    ntrials = 10
    iti = 10.0
    trial_starts = np.linspace(0, float(iti * ntrials), ntrials)  # Absolute experiment times
    # relative_spikes = [  # spike times here are relative to the trial start time
    #     np.array([0.1, 0.12, 0.14, 0.16, 1.5, 1.52, 1.54, 1.57, 1.59, 2.35, 2.47, 2.53]),  # Trial 0
    #     np.array([0.1, 0.12, 0.14, 0.16, 1.0, 1.02, 1.04]),  # Trial 1
    #     np.array([0.5, 0.6, 0.7, 1.5, 1.6, 1.7, 1.8, 1.9]),   # Trial 2
    #     4+ np.array([0.2, 0.25, 0.49, 1.25, 1.26, 1.275, 1.82, 1.9]),   # Trial 2
    #     5+ np.array([0.35, 0.42, 0.50, 0.52, 0.95, 0.105, 0.118, 0.138]),  # Trial 2
    # ]
    relative_spikes = burst_maker(
        ntrials=10,
        mean_spikes_per_burst=30,
        mean_interburst_interval=1.0,
        mean_interburst_std = 0.05,
        mean_burst_duration=0.5,
        trial_duration=10,
    )
    print(relative_spikes)

    analyzer = BurstAnalyzer(relative_spikes, trial_starts, max_ISI=0.1, min_spikes=3)

    # Get evolution in 2-trial bins
    evolution = analyzer.calculate_evolution(bin_type="mixed", bin_size=1)
    analyzer.plot_evolution(evolution, method="trial")
    mpl.show()
    print("Trial-binned evolution:")
    for bin_data in evolution["by_trial"]:
        print(
            f"Trials {bin_data['trials']} ({bin_data['start_time']:.1f}-{bin_data['end_time']:.1f}):"
        )
        print(
            f"  Bursts: {bin_data['n_bursts']} | Avg rate: {bin_data['mean_rate']:.2f} Hz | Avg duration: {bin_data['mean_duration']:.2f} s | Avg spikes: {bin_data['mean_spikes']:.2f}"
        )

    # print("\nTime-binned evolution (5s windows):")
    # for bin_data in evolution['by_time']:
    #     print(f"Time {bin_data['start']:.1f}-{bin_data['end']:.1f}:")
    #     print(f"  Bursts: {bin_data['n_bursts']} | Trials: {bin_data['trials_included']}")


# Example usage
if __name__ == "__main__":
    # Trial parameters (times in seconds)
    test()
